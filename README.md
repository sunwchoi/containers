# 프로젝트 소개

c++ stl의 일부 컨테이너를 재구현하는 과제

# 컨테이너란

같은 자료형의 원소들을 저장할 수 있는 객체이며, 멤버함수를 통해 원소에 대한 접근과 수정을 제공한다.

여러 컨테이너들은 크게 sequence container, associative container, container adapter, 이 3가지로 구분할 수 있고, 각 종류의 메서드는 거의 비슷하다.

sequence container는 원소를 삽입하는 시점과 지점에 따라 원소를 저장한다. 반면, associative container는 원소의 값에 따라 원소를 저장할 위치를 결정한다. container adapter같은 경우에는 이미 구현된 컨테이너를 내부 컨테이너로 쓰면서 메서드만 새롭게 정의한 컨테이너이다.

나는 vector, map, set, stack을 구현했다.

# Vector

벡터는 원소를 삽입하는 순서에 따라 저장하는 방식의 컨테이너이다.

![image](https://github.com/user-attachments/assets/eb98c515-1822-4fa1-9481-23e5921f1d8a)

## 구현


![image](https://github.com/user-attachments/assets/50663f2d-cdbe-4948-9825-d99ffef15957)

내부 배열과 포인터 3가지로 구현할 수 있다. 첫번째 포인터는 배열 자체를 가르키는 포인터이다. 

새롭게 원소가 삽입된다면, 기존 배열의 크기를 2배로 늘린 새 배열을 만들어 기존의 배열에 들어있던 원소를 복사한 후 맨 마지막에 새로운 원소를 삽입한다. 이때, 배열은 사용하는 공간보다 더 많이 할당이 되어있다. 따라서 두번째 포인터를 현재 사용하고 있는 배열의 끝을 가르키는 포인터로, 세번째 포인터는 실제 할당된 배열의 끝을 가르키는 포인터로 만들어 사용한다.

# Map & Set

맵은 원소의 key값을 기준으로 value를 저장하는 방식의 컨테이너이다. set은 원소의 value자체가 key값인 map이다.

![image](https://github.com/user-attachments/assets/2c924dd3-4902-4353-8647-7d54e1b26a11)

## 구현

map과 set은 내부적으로 rb트리라는 균형 이진 트리를 이용하여 구현되어있다. 나도 tree라는 내부컨테이너를 만들어 rb트리를 구현해 map과 set에 적용했다. rb트리 구현은 위키백과를 참고했다.

[레드-블랙 트리 위키백과](https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC)

## iterator

벡터는 결국 배열이기때문에 포인터를 순환자로 사용해도 문제없다. 예를 들어 순환자를 포인터로 사용했을때,  ++연산은 자동으로 벡터의 다음 원소를 가르킬 수 있다.

그러나, 맵과 셋의 경우에는 트리로 구현되어 있고 노드의 포인터에 ++연산을 할 경우, 할당되지 않은 공간을 가르키게 된다. 따라서 ++연산으로 트리를 중위 순회할 수 순환자 클래스를 따로 구현해야한다.

# Stack

스택은 기존 컨테이너를 내부 컨테이너로 사용하면서 자신의 메서드로만 내부 컨테이너로의 접근을 허용한다. 두번째 템플릿인자로 내부 컨테이너의 자료형을 받는다.
